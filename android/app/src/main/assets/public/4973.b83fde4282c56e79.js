"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[4973],{23506:(O,_,e)=>{e.d(_,{v:()=>r});var s=e(99305);function r(n){null!=n&&n.writtenProperties&&n.writtenProperties.forEach(({target:i,propName:u,newOrigin:a})=>{(0,s.H)(i)&&a&&i.originOf(u)!==a&&i.updateOrigin(u,a)})}},99305:(O,_,e)=>{function s(r){return r&&"getAtOrigin"in r&&"originOf"in r}e.d(_,{H:()=>s})},23518:(O,_,e)=>{e.r(_),e.d(_,{save:()=>P,saveAs:()=>g});var s=e(10467),r=e(17994),n=e(69927);const i="Image Service",u="imagery-layer-save",a="imagery-layer-save-as",l="imagery-tile-layer-save",f="imagery-tile-layer-save-as";function p(o){var t;if("imagery"===o.type)return{isValid:!0};const{raster:d}=o,v="Function"===(null==d?void 0:d.datasetFormat)?null===(t=d.primaryRasters)||void 0===t?void 0:t.rasters[0]:d;return{isValid:"RasterTileServer"===(null==v?void 0:v.datasetFormat)&&("Raster"===v.tileType||"Map"===v.tileType),errorMessage:"imagery tile layer should be created from a tiled image service."}}function y(o){const t=o.layerJSON;return Promise.resolve(t&&Object.keys(t).length?t:null)}function c(o,t){return m.apply(this,arguments)}function m(){return(m=(0,s.A)(function*(o,t){const{parsedUrl:d,title:v,fullExtent:h}=o;t.url=d.path,t.title||(t.title=v);try{t.extent=yield(0,n.sQ)(h)}catch{t.extent=void 0}(0,n.OM)(t,n.mm.METADATA),"imagery-tile"===o.type&&(0,n.LG)(t,n.mm.TILED_IMAGERY)})).apply(this,arguments)}function P(o,t){return E.apply(this,arguments)}function E(){return(E=(0,s.A)(function*(o,t){return(0,r.UN)({layer:o,itemType:i,validateLayer:p,createItemData:y,errorNamePrefix:"imagery"===o.type?u:l},t)})).apply(this,arguments)}function g(o,t,d){return A.apply(this,arguments)}function A(){return(A=(0,s.A)(function*(o,t,d){return(0,r.Uh)({layer:o,itemType:i,validateLayer:p,createItemData:y,errorNamePrefix:"imagery"===o.type?a:f,newItem:t,setItemProperties:c},d)})).apply(this,arguments)}},15764:(O,_,e)=>{e.d(_,{m:()=>i,v:()=>n});var s=e(45272),r=e(73874);function n(a,l){return{...u(a,l),readResourcePaths:[]}}function i(a,l,f){const p=(0,s.An)(a.itemUrl);return{...u(a,l),messages:[],writtenProperties:[],blockedRelativeUrls:[],verifyItemRelativeUrls:p?{rootPath:p.path,writtenUrls:[]}:null,resources:f?{toAdd:[],toUpdate:[],toKeep:[],pendingOperations:[]}:null}}function u(a,l){return{origin:l,url:(0,s.An)(a.itemUrl),portal:a.portal||r.A.getDefault(),portalItem:a}}},96904:(O,_,e)=>{e.d(_,{X:()=>i});var s=e(23098),r=e(5922),n=e(2174);function i(u){if(s.A.apiKey&&(0,n.Q)(u.portal.url))throw new r.A("save-api-key-utils:api-key-not-supported",`Saving is not supported on ${u.portal.url} when using an api key`)}},95945:(O,_,e)=>{e.d(_,{c:()=>a,d:()=>n});var s=e(10467),r=e(5922);function n(l){return i.apply(this,arguments)}function i(){return(i=(0,s.A)(function*(l){const f=[];for(const p of l.allLayers)if("beforeSave"in p&&"function"==typeof p.beforeSave){const y=p.beforeSave();y&&f.push(y)}yield Promise.allSettled(f)})).apply(this,arguments)}const u=new Set(["layer:unsupported","property:unsupported","symbol:unsupported","symbol-layer:unsupported","url:unsupported"]);function a(l,f,p){var y;let c=(null!==(y=l.messages)&&void 0!==y?y:[]).filter(({type:m})=>"error"===m).map(({name:m,message:P,details:E})=>new r.A(m,P,E));if(l.blockedRelativeUrls&&(c=c.concat(l.blockedRelativeUrls.map(m=>new r.A("url:unsupported",`Relative url '${m}' is not supported`)))),p){const{ignoreUnsupported:m,supplementalUnsupportedErrors:P=[],requiredPropertyChecksDisabled:E}=p;m&&(c=c.filter(({name:g})=>!(u.has(g)||P.includes(g)))),E&&(c=c.filter(g=>"web-document-write:property-required"!==g.name))}if(c.length>0)throw new r.A(f.errorName,"Failed to save due to unsupported or invalid content. See 'details.errors' for more detailed information",{errors:c})}}}]);