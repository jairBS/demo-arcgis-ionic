"use strict";(self.webpackChunkapp=self.webpackChunkapp||[]).push([[6443],{84149:(x,g,r)=>{r.d(g,{I:()=>d});var T=r(64662);class d{constructor(l){this._allocator=l,this._items=[],this._itemsPtr=0,this._grow()}get(){return 0===this._itemsPtr&&(0,T.d)(()=>this._reset()),this._itemsPtr===this._items.length&&this._grow(),this._items[this._itemsPtr++]}_reset(){const l=Math.min(3*Math.max(8,this._itemsPtr),this._itemsPtr+3*M);this._items.length=Math.min(l,this._items.length),this._itemsPtr=0}_grow(){for(let l=0;l<Math.max(8,Math.min(this._items.length,M));l++)this._items.push(this._allocator())}}const M=1024},16590:(x,g,r)=>{r.d(g,{g:()=>R});var T=r(25866),d=r(11817),M=r(23234);function R(_,c,m,P){var f,L;if((0,d.canProjectWithoutEngine)(_.spatialReference,m)){var C;v[0]=_.x,v[1]=_.y;const S=_.z;return v[2]=null!==(C=null!=S?S:P)&&void 0!==C?C:0,(0,M.projectBuffer)(v,_.spatialReference,0,c,m,0,1)}const i=(0,d.tryProjectWithZConversion)(_,m);return!!i&&(c[0]=null==i?void 0:i.x,c[1]=null==i?void 0:i.y,c[2]=null!==(f=null!==(L=null==i?void 0:i.z)&&void 0!==L?L:P)&&void 0!==f?f:0,!0)}const v=(0,T.vt)()},71698:(x,g,r)=>{r.r(g),r.d(g,{assetMapFromAssetMapsJSON:()=>B,extractMesh:()=>i,meshFeatureSetFromJSON:()=>L});var T=r(81098),d=r(35150),M=r(60797),R=r(28067),l=r(58864),I=r(13303),v=r(32034),_=r(36812),c=r(33019),m=r(6829),P=r(93327);const f=()=>d.A.getLogger("esri.rest.support.meshFeatureSet");function L(t,e,s){var n;const u=s.features;s.features=[],delete s.geometryType;const a=P.A.fromJSON(s);if(a.geometryType="mesh",!s.assetMaps)return a;const h=B(e,s.assetMaps),y=null!==(n=t.sourceSpatialReference)&&void 0!==n?n:v.A.WGS84,D=s.globalIdFieldName,{outFields:E}=t,A=null!=E&&E.length>0?function C(t){return({attributes:e})=>{if(!e)return{};if(!t)return e;for(const s in e)t.has(s)||delete e[s];return e}}(E.includes("*")?null:new Set(E)):()=>({});for(const p of u){const j=i(p,D,y,e,h);null!=j&&a.features.push(new T.A({geometry:j,attributes:A(p)}))}return a}function i(t,e,s,n,u){const h=u.get(t.attributes[e]);if(null==h)return f().error("mesh-feature-set:asset-not-found","Service returned a feature which was not found in the asset map",t),null;if(!t.geometry)return f().error("mesh-feature-set:no-geometry","Service returned a feature without geometry",t),null;const y=function S({attributes:t},e,{transformFieldRoles:s}){return new I.A({x:t[s.originX],y:t[s.originY],z:t[s.originZ],spatialReference:e})}(t,s,n),D=R.A.fromJSON(t.geometry);D.spatialReference=s;const E=function U(t,{transformFieldRoles:e}){return new _.A({translation:[t[e.translationX],-t[e.translationZ],t[e.translationY]],rotationAxis:[t[e.rotationX],-t[e.rotationZ],t[e.rotationY]],rotationAngle:t[e.rotationDeg],scale:[t[e.scaleX],t[e.scaleZ],t[e.scaleY]]})}(t.attributes,n),A=s.isGeographic?"local":"georeferenced",p=function W(t){const e=Array.from(t.files.values()),s=new Array;for(const n of e){if(n.status!==O.COMPLETED)return null;const u=new Array;for(const a of n.parts){if(!a)return null;u.push(new c.Bq(a.url,a.hash))}s.push(new c.Qp(n.name,n.mimeType,u))}return s}(h);return p?l.A.createWithExternalSource(y,p,{extent:D,transform:E,vertexSpace:A}):l.A.createIncomplete(y,{extent:D,transform:E,vertexSpace:A})}var O,t;function B(t,e){const s=new Map;for(const n of e){const u=n.parentGlobalId;if(null==u)continue;const a=n.assetName,h=n.assetType,y=n.assetHash,D=n.assetURL,E=n.conversionStatus,A=n.seqNo,p=(0,m.Fm)(h,t.supportedFormats);if(!p){f().error("mesh-feature-set:unknown-format",`Service returned an asset of type ${h}, but it does not list it as a supported type`);continue}const j=(0,M.tE)(s,u,()=>({files:new Map}));(0,M.tE)(j.files,a,()=>({name:a,type:h,mimeType:p,status:F(E),parts:[]})).parts[A]={hash:y,url:D}}return s}function F(t){switch(t){case"COMPLETED":case"SUBMITTED":return O.COMPLETED;case"INPROGRESS":return O.PENDING;default:return O.FAILED}}(t=O||(O={}))[t.FAILED=0]="FAILED",t[t.PENDING=1]="PENDING",t[t.COMPLETED=2]="COMPLETED"}}]);